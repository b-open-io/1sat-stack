package txo

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/b-open-io/1sat-stack/pkg/beef"
	"github.com/b-open-io/1sat-stack/pkg/pubsub"
	"github.com/b-open-io/1sat-stack/pkg/store"
	"github.com/bsv-blockchain/go-overlay-services/pkg/core/engine"
	"github.com/bsv-blockchain/go-sdk/chainhash"
	"github.com/bsv-blockchain/go-sdk/transaction"
)

// Storage key constants
const (
	outKey   = "out"  // Hash: outpoint -> binary(output fields)
	spndKey  = "spnd" // Hash: outpoint -> spend txid
	tdataKey = "data" // Hash: outpoint:tag -> binary(tag-specific data)
	evtKey   = "evt"  // Hash: outpoint -> JSON(events array)
	txidPfx  = "txid" // Sorted Set prefix: txid:{txid} -> outpoints
	satsKey  = "sats" // Hash: outpoint -> satoshis
	mrkKey   = "mrk"  // Hash: outpoint -> merkle state
)

// OutputStore provides output operations with key prefixing and spent filtering.
// It wraps Store and adds higher-level output management.
type OutputStore struct {
	Store     store.Store
	PubSub    pubsub.PubSub
	BeefStore *beef.Storage // Optional - nil for 1sat-indexer
	Prefix    string        // Topic prefix for key scoping
}

// NewOutputStore creates a new OutputStore with the given prefix
func NewOutputStore(s store.Store, ps pubsub.PubSub, prefix string) *OutputStore {
	return &OutputStore{
		Store:  s,
		PubSub: ps,
		Prefix: prefix,
	}
}

// key prepends the prefix to a base key and returns as []byte
func (s *OutputStore) key(base string) []byte {
	if s.Prefix == "" {
		return []byte(base)
	}
	return []byte(s.Prefix + ":" + base)
}

// storedOutput is the JSON structure stored in the output hash
type storedOutput struct {
	BlockHeight uint32  `json:"height"`
	BlockIdx    uint64  `json:"idx"`
	Satoshis    uint64  `json:"satoshis"`
	Owners      []Owner `json:"owners,omitempty"`
}

// === Core Output Operations ===

// LoadOutput loads a single output by outpoint
func (s *OutputStore) LoadOutput(ctx context.Context, outpoint string, tags []string, includeSpend bool) (*IndexedOutput, error) {
	value, err := s.Store.HGet(ctx, s.key(outKey), []byte(outpoint))
	if err != nil && err != store.ErrKeyNotFound {
		return nil, err
	}
	if len(value) == 0 {
		return nil, nil
	}

	output, err := s.parseOutput(outpoint, string(value))
	if err != nil {
		return nil, err
	}

	if len(tags) > 0 {
		if output.Data, err = s.loadTagData(ctx, outpoint, tags); err != nil {
			return nil, err
		}
	}

	if includeSpend {
		if spendStr, _ := s.GetSpend(ctx, outpoint); spendStr != "" {
			output.SpendTxid, _ = chainhash.NewHashFromHex(spendStr)
		}
	}

	return output, nil
}

// LoadOutputs loads multiple outputs by outpoints
func (s *OutputStore) LoadOutputs(ctx context.Context, outpoints []string, tags []string, includeSpend bool) ([]*IndexedOutput, error) {
	if len(outpoints) == 0 {
		return nil, nil
	}

	fields := make([][]byte, len(outpoints))
	for i, op := range outpoints {
		fields[i] = []byte(op)
	}

	values, err := s.Store.HMGet(ctx, s.key(outKey), fields...)
	if err != nil {
		return nil, err
	}

	outputs := make([]*IndexedOutput, len(outpoints))
	for i, outpoint := range outpoints {
		if len(values[i]) == 0 {
			continue
		}
		output, err := s.parseOutput(outpoint, string(values[i]))
		if err != nil {
			return nil, err
		}
		outputs[i] = output
	}

	if len(tags) > 0 {
		for i, outpoint := range outpoints {
			if outputs[i] != nil {
				if outputs[i].Data, err = s.loadTagData(ctx, outpoint, tags); err != nil {
					return nil, err
				}
			}
		}
	}

	if includeSpend {
		spends, err := s.GetSpends(ctx, outpoints)
		if err != nil {
			return nil, err
		}
		for i, output := range outputs {
			if output != nil && spends[i] != "" {
				output.SpendTxid, _ = chainhash.NewHashFromHex(spends[i])
			}
		}
	}

	return outputs, nil
}

// LoadOutputsByTxid loads all outputs for a transaction
func (s *OutputStore) LoadOutputsByTxid(ctx context.Context, txid string, tags []string, includeSpend bool) ([]*IndexedOutput, error) {
	results, err := s.Store.Search(ctx, &store.SearchCfg{
		Keys: [][]byte{s.key(txidPfx + ":" + txid)},
	})
	if err != nil {
		return nil, err
	}

	outpoints := make([]string, len(results))
	for i, r := range results {
		outpoints[i] = string(r.Member)
	}

	return s.LoadOutputs(ctx, outpoints, tags, includeSpend)
}

// SaveOutput saves a single output with its events
func (s *OutputStore) SaveOutput(ctx context.Context, output *IndexedOutput, txid string, score float64) error {
	outpoint := output.Outpoint.String()

	// Store base output data
	stored := storedOutput{
		BlockHeight: output.BlockHeight,
		BlockIdx:    output.BlockIdx,
		Satoshis:    output.Satoshis,
		Owners:      output.Owners,
	}
	outputJSON, err := json.Marshal(stored)
	if err != nil {
		return err
	}

	if err := s.Store.HSet(ctx, s.key(outKey), []byte(outpoint), outputJSON); err != nil {
		return err
	}

	// Store satoshis separately for balance queries
	if err := s.Store.HSet(ctx, s.key(satsKey), []byte(outpoint), []byte(strconv.FormatUint(output.Satoshis, 10))); err != nil {
		return err
	}

	// Build events list
	events := make([]string, 0, len(output.Events)+len(output.Owners)+1)
	events = append(events, txidPfx+":"+txid)
	events = append(events, output.Events...)

	for _, owner := range output.Owners {
		if !owner.IsZero() {
			events = append(events, "own:"+owner.String())
		}
	}

	// Store events for rollback
	if len(events) > 0 {
		eventsJSON, err := json.Marshal(events)
		if err != nil {
			return err
		}
		if err := s.Store.HSet(ctx, s.key(evtKey), []byte(outpoint), eventsJSON); err != nil {
			return err
		}
	}

	// Add to sorted sets for each event
	for _, event := range events {
		if err := s.Store.ZAdd(ctx, s.key(event), store.ScoredMember{
			Member: []byte(outpoint),
			Score:  score,
		}); err != nil {
			return err
		}
	}

	// Store tag-specific data
	for tag, data := range output.Data {
		if data != nil {
			dataJSON, err := json.Marshal(data)
			if err != nil {
				return err
			}
			if err := s.Store.HSet(ctx, s.key(tdataKey+":"+tag), []byte(outpoint), dataJSON); err != nil {
				return err
			}
		}
	}

	// Publish events
	if s.PubSub != nil {
		for _, event := range events {
			s.PubSub.Publish(ctx, s.Prefix+":"+event, outpoint)
		}
	}

	return nil
}

// SaveOutputs saves multiple outputs
func (s *OutputStore) SaveOutputs(ctx context.Context, outputs []*IndexedOutput, txid string, score float64) error {
	for _, output := range outputs {
		if err := s.SaveOutput(ctx, output, txid, score); err != nil {
			return err
		}
	}
	return nil
}

// SaveSpend marks an output as spent
func (s *OutputStore) SaveSpend(ctx context.Context, outpoint string, spendTxid string, score float64) error {
	if err := s.Store.HSet(ctx, s.key(spndKey), []byte(outpoint), []byte(spendTxid)); err != nil {
		return err
	}

	// Add to spent owner sets (own:{owner}:spnd pattern)
	eventsBytes, _ := s.Store.HGet(ctx, s.key(evtKey), []byte(outpoint))
	if len(eventsBytes) > 0 {
		var events []string
		if err := json.Unmarshal(eventsBytes, &events); err == nil {
			for _, event := range events {
				// If it's an owner event, add to spent set
				if len(event) > 4 && event[:4] == "own:" {
					ownerAddr := event[4:]
					spentKey := "own:" + ownerAddr + ":spnd"
					if err := s.Store.ZAdd(ctx, s.key(spentKey), store.ScoredMember{
						Member: []byte(outpoint),
						Score:  score,
					}); err != nil {
						return err
					}
				}
			}
		}
	}

	return nil
}

// SaveSpends marks multiple outputs as spent
func (s *OutputStore) SaveSpends(ctx context.Context, outpoints []string, spendTxid string, score float64) error {
	for _, outpoint := range outpoints {
		if err := s.SaveSpend(ctx, outpoint, spendTxid, score); err != nil {
			return err
		}
	}
	return nil
}

// GetSpend returns the spending txid for an outpoint
func (s *OutputStore) GetSpend(ctx context.Context, outpoint string) (string, error) {
	spend, err := s.Store.HGet(ctx, s.key(spndKey), []byte(outpoint))
	if err != nil && err == store.ErrKeyNotFound {
		return "", nil
	}
	return string(spend), err
}

// GetSpends returns the spending txids for multiple outpoints
func (s *OutputStore) GetSpends(ctx context.Context, outpoints []string) ([]string, error) {
	if len(outpoints) == 0 {
		return nil, nil
	}
	fields := make([][]byte, len(outpoints))
	for i, op := range outpoints {
		fields[i] = []byte(op)
	}
	values, err := s.Store.HMGet(ctx, s.key(spndKey), fields...)
	if err != nil {
		return nil, err
	}
	result := make([]string, len(values))
	for i, v := range values {
		result[i] = string(v)
	}
	return result, nil
}

// SetNewSpend atomically sets a spend if it doesn't exist, returns true if newly set
func (s *OutputStore) SetNewSpend(ctx context.Context, outpoint string, spendTxid string) (bool, error) {
	existing, err := s.GetSpend(ctx, outpoint)
	if err != nil {
		return false, err
	}
	if existing != "" {
		return false, nil // Already spent
	}
	if err := s.Store.HSet(ctx, s.key(spndKey), []byte(outpoint), []byte(spendTxid)); err != nil {
		return false, err
	}
	return true, nil
}

// UnsetSpends removes spend marks from multiple outpoints
func (s *OutputStore) UnsetSpends(ctx context.Context, outpoints []string) error {
	if len(outpoints) == 0 {
		return nil
	}
	fields := make([][]byte, len(outpoints))
	for i, op := range outpoints {
		fields[i] = []byte(op)
	}
	return s.Store.HDel(ctx, s.key(spndKey), fields...)
}

// GetSats returns the satoshi values for multiple outpoints
func (s *OutputStore) GetSats(ctx context.Context, outpoints []string) ([]uint64, error) {
	if len(outpoints) == 0 {
		return nil, nil
	}
	fields := make([][]byte, len(outpoints))
	for i, op := range outpoints {
		fields[i] = []byte(op)
	}
	values, err := s.Store.HMGet(ctx, s.key(satsKey), fields...)
	if err != nil {
		return nil, err
	}
	sats := make([]uint64, len(outpoints))
	for i, v := range values {
		if len(v) > 0 {
			sats[i], _ = strconv.ParseUint(string(v), 10, 64)
		}
	}
	return sats, nil
}

// Rollback removes all data for a transaction
func (s *OutputStore) Rollback(ctx context.Context, txid string) error {
	results, err := s.Store.Search(ctx, &store.SearchCfg{
		Keys: [][]byte{s.key(txidPfx + ":" + txid)},
	})
	if err != nil {
		return err
	}

	for _, r := range results {
		outpoint := string(r.Member)

		// Get events to remove from sorted sets
		eventsBytes, err := s.Store.HGet(ctx, s.key(evtKey), r.Member)
		if err != nil && err != store.ErrKeyNotFound {
			return err
		}

		if len(eventsBytes) > 0 {
			var events []string
			if err := json.Unmarshal(eventsBytes, &events); err == nil {
				for _, event := range events {
					s.Store.ZRem(ctx, s.key(event), r.Member)
				}
			}
		}

		// Remove hash entries
		s.Store.HDel(ctx, s.key(outKey), []byte(outpoint))
		s.Store.HDel(ctx, s.key(satsKey), []byte(outpoint))
		s.Store.HDel(ctx, s.key(evtKey), []byte(outpoint))
		s.Store.HDel(ctx, s.key(spndKey), []byte(outpoint))
	}

	return nil
}

// === Search Methods ===

// Search performs a multi-key search with optional spent filtering
func (s *OutputStore) Search(ctx context.Context, cfg *store.SearchCfg, includeSpent bool) ([]store.ScoredMember, error) {
	// Prefix all keys in cfg
	prefixedCfg := *cfg
	prefixedCfg.Keys = make([][]byte, len(cfg.Keys))
	for i, k := range cfg.Keys {
		if s.Prefix == "" {
			prefixedCfg.Keys[i] = k
		} else {
			prefixedCfg.Keys[i] = []byte(s.Prefix + ":" + string(k))
		}
	}

	results, err := s.Store.Search(ctx, &prefixedCfg)
	if err != nil {
		return nil, err
	}

	if !includeSpent {
		return s.filterSpent(ctx, results)
	}
	return results, nil
}

// SearchOutputs searches and loads full output data
func (s *OutputStore) SearchOutputs(ctx context.Context, cfg *store.SearchCfg, tags []string, includeSpent bool) ([]*IndexedOutput, error) {
	results, err := s.Search(ctx, cfg, includeSpent)
	if err != nil {
		return nil, err
	}

	outpoints := make([]string, len(results))
	for i, r := range results {
		outpoints[i] = string(r.Member)
	}
	return s.LoadOutputs(ctx, outpoints, tags, includeSpent)
}

// SearchBalance calculates total satoshi balance (always excludes spent)
func (s *OutputStore) SearchBalance(ctx context.Context, cfg *store.SearchCfg) (uint64, error) {
	results, err := s.Search(ctx, cfg, false) // includeSpent=false
	if err != nil {
		return 0, err
	}

	outpoints := make([]string, len(results))
	for i, r := range results {
		outpoints[i] = string(r.Member)
	}

	sats, err := s.GetSats(ctx, outpoints)
	if err != nil {
		return 0, err
	}

	var balance uint64
	for _, sat := range sats {
		balance += sat
	}
	return balance, nil
}

// filterSpent removes spent outputs from results
func (s *OutputStore) filterSpent(ctx context.Context, results []store.ScoredMember) ([]store.ScoredMember, error) {
	outpoints := make([]string, len(results))
	for i, r := range results {
		outpoints[i] = string(r.Member)
	}

	spends, err := s.GetSpends(ctx, outpoints)
	if err != nil {
		return nil, err
	}

	unspent := make([]store.ScoredMember, 0, len(results))
	for i, r := range results {
		if spends[i] == "" {
			unspent = append(unspent, r)
		}
	}
	return unspent, nil
}

// === Sorted Set Logging (thin wrappers with prefix) ===

// Log adds an entry to a sorted set
func (s *OutputStore) Log(ctx context.Context, key, id string, score float64) error {
	return s.Store.ZAdd(ctx, s.key(key), store.ScoredMember{Member: []byte(id), Score: score})
}

// LogMany adds multiple entries to a sorted set
func (s *OutputStore) LogMany(ctx context.Context, key string, logs []store.ScoredMember) error {
	return s.Store.ZAdd(ctx, s.key(key), logs...)
}

// Delog removes entries from a sorted set
func (s *OutputStore) Delog(ctx context.Context, key string, ids ...string) error {
	members := make([][]byte, len(ids))
	for i, id := range ids {
		members[i] = []byte(id)
	}
	return s.Store.ZRem(ctx, s.key(key), members...)
}

// LogScore returns the score of an entry in a sorted set
func (s *OutputStore) LogScore(ctx context.Context, key, id string) (float64, error) {
	score, err := s.Store.ZScore(ctx, s.key(key), []byte(id))
	if err != nil && err == store.ErrKeyNotFound {
		return 0, nil
	}
	return score, err
}

// === Event Operations ===

// SaveEvents saves events for an outpoint
func (s *OutputStore) SaveEvents(ctx context.Context, outpoint string, events []string, score float64) error {
	eventsJSON, err := json.Marshal(events)
	if err != nil {
		return err
	}
	return s.Store.HSet(ctx, s.key(evtKey), []byte(outpoint), eventsJSON)
}

// FindEvents retrieves events for an outpoint
func (s *OutputStore) FindEvents(ctx context.Context, outpoint string) ([]string, error) {
	eventsBytes, err := s.Store.HGet(ctx, s.key(evtKey), []byte(outpoint))
	if err != nil && err != store.ErrKeyNotFound {
		return nil, err
	}
	if len(eventsBytes) == 0 {
		return nil, nil
	}
	var events []string
	err = json.Unmarshal(eventsBytes, &events)
	return events, err
}

// === Merkle State (for overlay) ===

// merkleData is the JSON structure for merkle state storage
type merkleData struct {
	State engine.MerkleState `json:"state"`
	Root  string             `json:"root,omitempty"`
}

// UpdateMerkleState updates the merkle state for an outpoint
func (s *OutputStore) UpdateMerkleState(ctx context.Context, outpoint string, state engine.MerkleState, root string) error {
	data := merkleData{State: state, Root: root}
	dataJSON, err := json.Marshal(data)
	if err != nil {
		return err
	}
	return s.Store.HSet(ctx, s.key(mrkKey), []byte(outpoint), dataJSON)
}

// GetMerkleState retrieves the merkle state for an outpoint
func (s *OutputStore) GetMerkleState(ctx context.Context, outpoint string) (engine.MerkleState, string, error) {
	dataBytes, err := s.Store.HGet(ctx, s.key(mrkKey), []byte(outpoint))
	if err != nil && err != store.ErrKeyNotFound {
		return 0, "", err
	}
	if len(dataBytes) == 0 {
		return 0, "", nil
	}
	var data merkleData
	if err := json.Unmarshal(dataBytes, &data); err != nil {
		return 0, "", err
	}
	return data.State, data.Root, nil
}

// === Helper Methods ===

// parseOutput parses stored JSON into an IndexedOutput
func (s *OutputStore) parseOutput(outpoint string, value string) (*IndexedOutput, error) {
	op, err := transaction.OutpointFromString(outpoint)
	if err != nil {
		return nil, err
	}

	var stored storedOutput
	if err := json.Unmarshal([]byte(value), &stored); err != nil {
		return nil, err
	}

	return &IndexedOutput{
		Output: engine.Output{
			Outpoint:    *op,
			BlockHeight: stored.BlockHeight,
			BlockIdx:    stored.BlockIdx,
		},
		Satoshis: stored.Satoshis,
		Owners:   stored.Owners,
		Data:     make(map[string]interface{}),
	}, nil
}

// loadTagData loads tag-specific data for an outpoint
func (s *OutputStore) loadTagData(ctx context.Context, outpoint string, tags []string) (map[string]interface{}, error) {
	if len(tags) == 0 {
		return nil, nil
	}

	data := make(map[string]interface{}, len(tags))
	for _, tag := range tags {
		value, err := s.Store.HGet(ctx, s.key(tdataKey+":"+tag), []byte(outpoint))
		if err != nil && err != store.ErrKeyNotFound {
			return nil, err
		}
		if len(value) > 0 {
			var tagData interface{}
			if err := json.Unmarshal(value, &tagData); err != nil {
				return nil, err
			}
			data[tag] = tagData
		}
	}
	return data, nil
}
